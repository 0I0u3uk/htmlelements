1.9 - What's New?
=================

In this version we worked mainly to solve the problems found by our community.
We'd fixed some architecture drawbacks (`Checkbox`, `AjaxElementLocator`) and a couple of bugs with `List<HtmlElements>`.
We've got a new contributors as well! Big thanks to [@lanwen](http://github.com/lanwen) for withWaitFor-matcher implementation.
In spite of the fact that we still didn't accept this pull-request, we'd like to thank [@pazone](http://github.com/pazone) for the idea of matcher which recursively checks the elements present. We hope it'll be included in the next release.

If you still didn't get a "thanks" from [Yandex QATools](https://github.com/yandex-qatools) team, be free to send us your ideas and your code as well.

So it's time to talk about new features...

HtmlElements All
----------------

Issue #18

We've made a separate module which contains latest versions of htmlelements-java and htmlelements-matchers.
So you can use only one dependency instead of two:

    <groupId>ru.yandex.qatools.htmlelements</groupId>
    <artifactId>htmlelements-all</artifactId>
    <version>1.9</version>

In case you use only one of this modules, nothing will change for you.

WaitFor Matcher
---------------

Issue #10

In order to support client-side java-script, we need to use a lot of different time-outs in our tests. "WaitFor" matcher solves this problem.
Here is an example:

    MainPage mainPage = new MainPage(driver);
    mainPage.getSearchArrow().getRequestInput().sendKeys(REQUEST);
    assertThat(mainPage.getSuggest(), withWaitFor(exists()));

The exists() matcher will be executed every 30ms until it'll return true or 30000ms (default timeout) will be reached.
In case of error you will get the following message:

    Expected: While waiting [<30000L>] millis it should be: element existing on page
         but: element Suggest not existing on page
         
Or you can define your custom time-out:

    int timeoutInMilliseconds = 10000; //10 секунд

    MainPage mainPage = new MainPage(driver);
    mainPage.getSearchArrow().getRequestInput().sendKeys(REQUEST);
    assertThat(mainPage.getSuggest(), withWaitFor(exists(), timeoutInMilliseconds));

And even a check period:

или так:

    int timeoutInMilliseconds = 10000; //10 секунд
    int intervalInMilliseconds = 50; //50 милисекунд

    MainPage mainPage = new MainPage(driver);
    mainPage.getSearchArrow().getRequestInput().sendKeys(REQUEST);
    assertThat(mainPage.getSuggest(), withWaitFor(exists(), timeoutInMilliseconds, intervalInMilliseconds));

A really nice matcher!

List<? extend HtmlElement> initialization
-----------------------------------------

Issue #17

It was a lot of comparisons when you've tried to access list of HtmlElements (or TypifiedElement-). As the result such collections have worked quite slowly.
The bug was in a naming algorithm and we've fixed it.

TypifiedElements useful methods added
-------------------------------------

Issue #15

Turned out that `isDisplayed()`, `isEnabled()`, `isSelected()` methods are pretty useful for all types of elements.
So we've added them to the base class TypifiedElements.

Update Selenium Version
-----------------------

Issue #9

Selenium version was upgraded to 2.29.0

AjaxElementLocator
------------------

Issue #3

One of the main features in this release - is using `AjaxElementLocator` as a default.
It allows to make elements initialization over a some period (5 seconds by default). The name `Ajax...` explains a lot.
We've added an ability to use your own ElementLocator as well:

    HtmlElementLoader.createHtmlElement(Class<T> clazz, CustomElementLocatorFactory locatorFactory)
    HtmlElementLoader.populateHtmlElement(HtmlElement htmlElement, CustomElementLocatorFactory locatorFactory)

Checkbox
--------

Issue #14

The typified elements concept is quite green yet, but we'll work on it in the next release.
It was an architecture bug in previous implementation:

    public void select() {
        if (!getWrappedElement().isSelected()) {
            getWrappedElement().click();
        }
    }

    public void deselect() {
        if (getWrappedElement().isSelected()) {
            getWrappedElement().click();
        }
    }

    public boolean isSelected() {
        return getWrappedElement().isSelected();
    }

In case you need to override `isSelected()` method, you'd need to override the rest methods as well (because they depend on WrappedElement status).
We've decided to change the `select()` and  `deselect()` implementations to use isSelected() method.

    public void select() {
        if (!isSelected()) {
            getWrappedElement().click();
        }
    }

And that is all (in 1.9 version)!
It's time to safe the world now)