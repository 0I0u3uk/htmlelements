Html Elements 1.9 – What's New?
===============================

While developing a new version of our framework we mainly worked on the drawbacks that were found by the members our 
community. We have fixed some architectural problem and a couple of bugs with initialization of 
`List<Т extends HtmlElements>`.

And we've got a new contributors as well! Thanks a lot to [@lanwen](http://github.com/lanwen) for the great 
WaitFor-matcher implementation. And though there is still unaccepted pull-request, 
We'd also like to thank [@pazone](http://github.com/pazone) for the idea of the matcher which recursively checks 
that elements of a block exsist on a page, though the pull-request is still unaccepted. We hope it will be included 
in the next release.

If you still haven't got a "thanks" from [Yandex QATools](https://github.com/yandex-qatools) team, feel free to send 
us your ideas and your code as well.

And it's time for a more detailed review of the new features.

Default usage of AjaxElementLocator
-----------------------------------

[Issue #3](https://github.com/yandex-qatools/htmlelements/issues/3)

One of the main and most important features of this release is using `AjaxElementLocator` by default.
It allows to make elements initialization over a some period (5 seconds by default). The name `Ajax...` explains a lot.
We've added an ability to use your own ElementLocator as well:

    HtmlElementLoader.createHtmlElement(Class<T> clazz, CustomElementLocatorFactory locatorFactory)
    HtmlElementLoader.populateHtmlElement(HtmlElement htmlElement, CustomElementLocatorFactory locatorFactory)


HtmlElements All
----------------

Issue #18

We've made a separate module which contains latest versions of htmlelements-java and htmlelements-matchers.
So you can use only one dependency instead of two:

    <groupId>ru.yandex.qatools.htmlelements</groupId>
    <artifactId>htmlelements-all</artifactId>
    <version>1.9</version>

In case you use only one of this modules, nothing will change for you.

WaitFor Matcher
---------------

Issue #10

In order to support client-side java-script, we need to use a lot of different time-outs in our tests. "WaitFor" matcher solves this problem.
Here is an example:

    MainPage mainPage = new MainPage(driver);
    mainPage.getSearchArrow().getRequestInput().sendKeys(REQUEST);
    assertThat(mainPage.getSuggest(), withWaitFor(exists()));

The exists() matcher will be executed every 30ms until it'll return true or 30000ms (default timeout) will be reached.
In case of error you will get the following message:

    Expected: While waiting [<30000L>] millis it should be: element existing on page
         but: element Suggest not existing on page
         
Or you can define your custom time-out:

    int timeoutInMilliseconds = 10000; //10 секунд

    MainPage mainPage = new MainPage(driver);
    mainPage.getSearchArrow().getRequestInput().sendKeys(REQUEST);
    assertThat(mainPage.getSuggest(), withWaitFor(exists(), timeoutInMilliseconds));

And even a check period:

или так:

    int timeoutInMilliseconds = 10000; //10 секунд
    int intervalInMilliseconds = 50; //50 милисекунд

    MainPage mainPage = new MainPage(driver);
    mainPage.getSearchArrow().getRequestInput().sendKeys(REQUEST);
    assertThat(mainPage.getSuggest(), withWaitFor(exists(), timeoutInMilliseconds, intervalInMilliseconds));

A really nice matcher!

List<? extend HtmlElement> initialization
-----------------------------------------

Issue #17

It was a lot of comparisons when you've tried to access list of HtmlElements (or TypifiedElement-). As the result such collections have worked quite slowly.
The bug was in a naming algorithm and we've fixed it.

TypifiedElements useful methods added
-------------------------------------

Issue #15

Turned out that `isDisplayed()`, `isEnabled()`, `isSelected()` methods are pretty useful for all types of elements.
So we've added them to the base class TypifiedElements.

Update Selenium Version
-----------------------

Issue #9

Selenium version was upgraded to 2.29.0

Checkbox
--------

Issue #14

The typified elements concept is quite green yet, but we'll work on it in the next release.
It was an architecture bug in previous implementation:

    public void select() {
        if (!getWrappedElement().isSelected()) {
            getWrappedElement().click();
        }
    }

    public void deselect() {
        if (getWrappedElement().isSelected()) {
            getWrappedElement().click();
        }
    }

    public boolean isSelected() {
        return getWrappedElement().isSelected();
    }

In case you need to override `isSelected()` method, you'd need to override the rest methods as well (because they depend on WrappedElement status).
We've decided to change the `select()` and  `deselect()` implementations to use isSelected() method.

    public void select() {
        if (!isSelected()) {
            getWrappedElement().click();
        }
    }

And that is all (in 1.9 version)!
It's time to safe the world now)
